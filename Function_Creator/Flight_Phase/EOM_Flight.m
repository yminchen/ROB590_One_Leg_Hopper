%% script SymbolicComputationOfEQM

% Author: Yu-Ming Chen, University of Michigan, Ann Arbor
% Email: yminchen@umich.edu
% Date: 01/08/2017 

% This code is modified from an example "SymbolicComputationofEOM.m"
% shared by Nils Smit-Anseeuw, University of Michigan, Ann Arbor.

% This MATLAB script performs the symbolic computation of the individual
% components of the equations of motion (Mass Matrix, Differentiable
% Forces, etc.).  The resulting functions are saved as automatically
% generated mat-files in the directory 'AutoGeneratedFcts'.  

%% Definitions
clear
% Generalized coordinates
syms x1 y1 theta s phi
q    = [x1 y1 theta s phi];
% Generalized speeds
syms dx1 dy1 dtheta ds dphi
dqdt = [dx1 dy1 dtheta ds dphi];


% Define the necessary parameter subset:
% Gravity
syms g
% Spring stiffness 
syms k 
% Segment dimensions:
syms L_sp0 L_m1     % spring original length and body length 
% Masses/Inertia:
syms m1 I1
syms m2

param = [g k L_sp0 L_m1 m1 I1 m2];


%% DYNAMICS (obtained via the Euler-Lagrange equation)

% CoG-positions (from kinematics):
CoG_m1 = [x1;
          y1];
CoG_m2 = [x1 + s*sin(theta+phi);
          y1 - s*cos(theta+phi)];
         
% CoG-velocities (computed via jacobians):
d_CoG_m1 = jacobian(CoG_m1,q)*dqdt.';
d_CoG_m2 = jacobian(CoG_m2,q)*dqdt.';

% Potential Energy (due to gravity):
V = CoG_m1(2)*m1*g + CoG_m2(2)*m2*g + 0.5*k*(s-L_sp0)^2;
V = simplify(V);

% Kinetic Energy:         
T = 0.5 * (m1 * sum(d_CoG_m1.^2) + ...
           m2 * sum(d_CoG_m2.^2) + ...
           I1 * dtheta^2 );
T = simplify(T);

% Lagrangian:
L = T-V;
% Partial derivatives:
dLdq   = jacobian(L,q).';
dLdqdt = jacobian(L,dqdt).';
      
% Compute Mass Matrix and its inverse:
M = jacobian(dLdqdt,dqdt);
M = simplify(M);
invM = inv(M);
invM = simplify(invM);

% Compute the coriolis and gravitational forces:
dL_dqdt_dt = jacobian(dLdqdt,q)*dqdt.';
f_cg = dLdq - dL_dqdt_dt;
f_cg = simplify(f_cg);

% The equations of motion are given with these functions as:   
% M * dqddt = f_cg(q, dqdt) + u;

%% KINEMATICS (for collision detection and graphical output)
% Two ends of body:
BodyL = [x1 - L_m1/2*cos(theta);
         y1 - L_m1/2*sin(theta)];
BodyR = [x1 + L_m1/2*cos(theta);
         y1 + L_m1/2*sin(theta)];
             
% Jacobian of two ends of body:
JBodyL = jacobian(BodyL,q);
JBodyL = simplify(JBodyL);
JBodyR = jacobian(BodyR,q);
JBodyR = simplify(JBodyR);

% CoGs (incl orientation of the segments) use for animations:
CoGs = [CoG_m1, CoG_m2;
        theta , 0];

% Links use for animations
links = [BodyL, BodyR, CoG_m1, CoG_m2];
links = simplify(links);

%% Create MATLAB-functions:
if ~exist('AutoGeneratedFcts','dir')
    mkdir('AutoGeneratedFcts')
end

matlabFunction(M,'file','AutoGeneratedFcts\MassMatrix','vars',[q, param]);
matlabFunction(invM,'file','AutoGeneratedFcts\InvMassMatrix','vars',[q, param]);
matlabFunction(f_cg,'file','AutoGeneratedFcts\F_CoriGrav','vars',[q, dqdt, param]);

matlabFunction(BodyL,'file','AutoGeneratedFcts\BodyL','vars',[q, param]);
matlabFunction(BodyR,'file','AutoGeneratedFcts\BodyR','vars',[q, param]);
matlabFunction(JBodyL,'file','AutoGeneratedFcts\ContactJacobianL','vars',[q, param]);
matlabFunction(JBodyR,'file','AutoGeneratedFcts\ContactJacobianR','vars',[q, param]);
matlabFunction(CoGs,'file','AutoGeneratedFcts\CoGPositions','vars',[q, param]);
matlabFunction(links,'file','AutoGeneratedFcts\LinkPositions','vars',[q, param]);